using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Numerics;
using System.Runtime.InteropServices;

namespace Voxels
{
    /// <summary>
    /// Support for reading .VOX files generated by Ephtracy's MagicaVoxel Tool.
    /// https://ephtracy.github.io/
    /// </summary>
    public class MagicaVoxel {
        public int Version { get; private set; } = 200;
        public List<Node> Nodes { get; private set; } = new List<Node>();
        public List<VoxelData> Models { get; private set; } = new List<VoxelData>();
        public Dictionary<int,Layer> Layers { get; private set; } = DefaultLayers;
        public Color[] Palette { get; private set; } = DefaultPalette;

        public MagicaVoxel() { }

        public MagicaVoxel(VoxelData voxelData) {
            Version = 150;
            Models.Add(voxelData);
            Palette = voxelData.Colors;
        }

        public class Node {
            public int id;
            public DICT attributes = new DICT();
        }

        public class TransformNode : Node {
            public int childNodeId;
            public int layerId;
            public string name;
            public bool hidden;

            public List<TransformFrame> Frames { get; } = new List<TransformFrame>();

            /// <summary>
            /// Interpolate matrix based on key frames.
            /// </summary>
            public Matrix4x4 GetFrameMatrix(int frameIndex) {
                TransformFrame lastFrame = null;
                foreach (var frame in Frames) {
                    if (frame.frameIndex == frameIndex) {
                        return frame.matrix;
                    }
                    if (frame.frameIndex > frameIndex) {
                        var t = ((float)frameIndex - lastFrame.frameIndex)/(frame.frameIndex - lastFrame.frameIndex);
                        var matrix = lastFrame.matrix;
                        matrix.Translation = XYZ.FromVector3(Vector3.Lerp(lastFrame.matrix.Translation, frame.matrix.Translation, t)).ToVector3();
                        return matrix;
                    }
                    lastFrame = frame;
                }
                return lastFrame.matrix;
            }

            public override string ToString() => name;
        }

        public class GroupNode : Node {
            public List<int> ChildNodeIds { get; } = new List<int>();
        }

        public class ShapeNode : Node {
            public List<ShapeModel> Models { get; } = new List<ShapeModel>();

            /// <summary>
            /// Find nearest frame with frameIndex greater than or equal to requested frameIndex.
            /// </summary>
            public ShapeModel GetModel(int frameIndex) {
                ShapeModel lastModel = null;
                foreach (var model in Models) {
                    if (model.frameIndex == frameIndex) {
                        return model;
                    }
                    if (model.frameIndex > frameIndex) {
                        return lastModel;
                    }
                    lastModel = model;
                }
                if (lastModel.frameIndex == 0) {
                    frameIndex = 0;
                }
                else {
                    frameIndex -= lastModel.frameIndex;
                }
                return GetModel(frameIndex);
            }
        }

        public class ShapeModel {
            public int modelId;
            public int frameIndex;

            public static ShapeModel Read(BinaryReader reader) {
                var model = new ShapeModel();

                model.modelId = reader.ReadInt32();

                var dict = ReadDICT(reader);
                if (dict.TryGetValue("_f", out var f)) {
                    model.frameIndex = int.Parse(f);
                }

                return model;
            }
        }

        public class TransformFrame {
            public int frameIndex;
            public Matrix4x4 matrix = Matrix4x4.Identity;

            public static TransformFrame Read(BinaryReader reader) {
                var frame = new TransformFrame();

                var dict = ReadDICT(reader);
                if (dict.TryGetValue("_r", out var r)) {
                    var b = byte.Parse(r);
                    var i1 = (b & 0b00000011) >> 0;
                    var i2 = (b & 0b00001100) >> 2;
                    var i3 = (i1 != 0 && i2 != 0) ? 0 : (i1 != 1 && i2 != 1) ? 1 : 2;
                    var s1 = (b & 0b00010000) >> 4 == 0 ? 1 : -1;
                    var s2 = (b & 0b00100000) >> 5 == 0 ? 1 : -1;
                    var s3 = (b & 0b01000000) >> 6 == 0 ? 1 : -1;

                    frame.matrix.M11 = i1 == 0 ? s1 : 0;
                    frame.matrix.M21 = i1 == 1 ? s1 : 0;
                    frame.matrix.M31 = i1 == 2 ? s1 : 0;

                    frame.matrix.M12 = i2 == 0 ? s2 : 0;
                    frame.matrix.M22 = i2 == 1 ? s2 : 0;
                    frame.matrix.M32 = i2 == 2 ? s2 : 0;

                    frame.matrix.M13 = i3 == 0 ? s3 : 0;
                    frame.matrix.M23 = i3 == 1 ? s3 : 0;
                    frame.matrix.M33 = i3 == 2 ? s3 : 0;
                }
                if (dict.TryGetValue("_t", out var t)) {
                    var xyz = t.Split(' ').Select(int.Parse).ToArray();
                    frame.matrix.Translation = new Vector3(xyz[0], xyz[1], xyz[2]);
                }
                if (dict.TryGetValue("_f", out var f)) {
                    frame.frameIndex = int.Parse(f);
                }

                return frame;
            }
        }

        public class Layer {
            public int layerId;
            public string layerName;
            public bool hidden;

            public static Layer Read(BinaryReader reader) {
                var layer = new Layer();

                layer.layerId = reader.ReadInt32();

                var layerAttributes = ReadDICT(reader);
                if (layerAttributes.TryGetValue("_name", out var layerName)) {
                    layer.layerName = layerName;
                }
                if (layerAttributes.TryGetValue("_hidden", out var hidden)) {
                    layer.hidden = (hidden == "1");
                }

                var reservedId = reader.ReadInt32(); Debug.Assert(reservedId == -1);

                return layer;
            }

            public override string ToString() => layerName ?? layerId.ToString();
        }

        public class DICT : Dictionary<string, string> { }

        static Dictionary<int,Layer> DefaultLayers => Enumerable.Range(0,16).ToDictionary(i => i, i => new Layer { layerId = i });

        static Color[] DefaultPalette => DefaultColors.Select(c => new Color(c)).ToArray();

        static readonly uint[] DefaultColors = new uint[] { // 0xAABBGGRR (little endian)
            0x00000000, 0xffffffff, 0xffccffff, 0xff99ffff, 0xff66ffff, 0xff33ffff, 0xff00ffff, 0xffffccff, 0xffccccff, 0xff99ccff, 0xff66ccff, 0xff33ccff, 0xff00ccff, 0xffff99ff, 0xffcc99ff, 0xff9999ff,
            0xff6699ff, 0xff3399ff, 0xff0099ff, 0xffff66ff, 0xffcc66ff, 0xff9966ff, 0xff6666ff, 0xff3366ff, 0xff0066ff, 0xffff33ff, 0xffcc33ff, 0xff9933ff, 0xff6633ff, 0xff3333ff, 0xff0033ff, 0xffff00ff,
            0xffcc00ff, 0xff9900ff, 0xff6600ff, 0xff3300ff, 0xff0000ff, 0xffffffcc, 0xffccffcc, 0xff99ffcc, 0xff66ffcc, 0xff33ffcc, 0xff00ffcc, 0xffffcccc, 0xffcccccc, 0xff99cccc, 0xff66cccc, 0xff33cccc,
            0xff00cccc, 0xffff99cc, 0xffcc99cc, 0xff9999cc, 0xff6699cc, 0xff3399cc, 0xff0099cc, 0xffff66cc, 0xffcc66cc, 0xff9966cc, 0xff6666cc, 0xff3366cc, 0xff0066cc, 0xffff33cc, 0xffcc33cc, 0xff9933cc,
            0xff6633cc, 0xff3333cc, 0xff0033cc, 0xffff00cc, 0xffcc00cc, 0xff9900cc, 0xff6600cc, 0xff3300cc, 0xff0000cc, 0xffffff99, 0xffccff99, 0xff99ff99, 0xff66ff99, 0xff33ff99, 0xff00ff99, 0xffffcc99,
            0xffcccc99, 0xff99cc99, 0xff66cc99, 0xff33cc99, 0xff00cc99, 0xffff9999, 0xffcc9999, 0xff999999, 0xff669999, 0xff339999, 0xff009999, 0xffff6699, 0xffcc6699, 0xff996699, 0xff666699, 0xff336699,
            0xff006699, 0xffff3399, 0xffcc3399, 0xff993399, 0xff663399, 0xff333399, 0xff003399, 0xffff0099, 0xffcc0099, 0xff990099, 0xff660099, 0xff330099, 0xff000099, 0xffffff66, 0xffccff66, 0xff99ff66,
            0xff66ff66, 0xff33ff66, 0xff00ff66, 0xffffcc66, 0xffcccc66, 0xff99cc66, 0xff66cc66, 0xff33cc66, 0xff00cc66, 0xffff9966, 0xffcc9966, 0xff999966, 0xff669966, 0xff339966, 0xff009966, 0xffff6666,
            0xffcc6666, 0xff996666, 0xff666666, 0xff336666, 0xff006666, 0xffff3366, 0xffcc3366, 0xff993366, 0xff663366, 0xff333366, 0xff003366, 0xffff0066, 0xffcc0066, 0xff990066, 0xff660066, 0xff330066,
            0xff000066, 0xffffff33, 0xffccff33, 0xff99ff33, 0xff66ff33, 0xff33ff33, 0xff00ff33, 0xffffcc33, 0xffcccc33, 0xff99cc33, 0xff66cc33, 0xff33cc33, 0xff00cc33, 0xffff9933, 0xffcc9933, 0xff999933,
            0xff669933, 0xff339933, 0xff009933, 0xffff6633, 0xffcc6633, 0xff996633, 0xff666633, 0xff336633, 0xff006633, 0xffff3333, 0xffcc3333, 0xff993333, 0xff663333, 0xff333333, 0xff003333, 0xffff0033,
            0xffcc0033, 0xff990033, 0xff660033, 0xff330033, 0xff000033, 0xffffff00, 0xffccff00, 0xff99ff00, 0xff66ff00, 0xff33ff00, 0xff00ff00, 0xffffcc00, 0xffcccc00, 0xff99cc00, 0xff66cc00, 0xff33cc00,
            0xff00cc00, 0xffff9900, 0xffcc9900, 0xff999900, 0xff669900, 0xff339900, 0xff009900, 0xffff6600, 0xffcc6600, 0xff996600, 0xff666600, 0xff336600, 0xff006600, 0xffff3300, 0xffcc3300, 0xff993300,
            0xff663300, 0xff333300, 0xff003300, 0xffff0000, 0xffcc0000, 0xff990000, 0xff660000, 0xff330000, 0xff0000ee, 0xff0000dd, 0xff0000bb, 0xff0000aa, 0xff000088, 0xff000077, 0xff000055, 0xff000044,
            0xff000022, 0xff000011, 0xff00ee00, 0xff00dd00, 0xff00bb00, 0xff00aa00, 0xff008800, 0xff007700, 0xff005500, 0xff004400, 0xff002200, 0xff001100, 0xffee0000, 0xffdd0000, 0xffbb0000, 0xffaa0000,
            0xff880000, 0xff770000, 0xff550000, 0xff440000, 0xff220000, 0xff110000, 0xffeeeeee, 0xffdddddd, 0xffbbbbbb, 0xffaaaaaa, 0xff888888, 0xff777777, 0xff555555, 0xff444444, 0xff222222, 0xff111111,
        };

        const uint VOX_ = ('V') + ('O' << 8) + ('X' << 16) + (' ' << 24);
        const uint MAIN = ('M') + ('A' << 8) + ('I' << 16) + ('N' << 24);
        const uint PACK = ('P') + ('A' << 8) + ('C' << 16) + ('K' << 24);
        const uint SIZE = ('S') + ('I' << 8) + ('Z' << 16) + ('E' << 24);
        const uint XYZI = ('X') + ('Y' << 8) + ('Z' << 16) + ('I' << 24);
        const uint RGBA = ('R') + ('G' << 8) + ('B' << 16) + ('A' << 24);
        const uint nTRN = ('n') + ('T' << 8) + ('R' << 16) + ('N' << 24);
        const uint nGRP = ('n') + ('G' << 8) + ('R' << 16) + ('P' << 24);
        const uint nSHP = ('n') + ('S' << 8) + ('H' << 16) + ('P' << 24);
        const uint LAYR = ('L') + ('A' << 8) + ('Y' << 16) + ('R' << 24);
        const uint MATL = ('M') + ('A' << 8) + ('T' << 16) + ('L' << 24);
        const uint rOBJ = ('r') + ('O' << 8) + ('B' << 16) + ('J' << 24);
        const uint rCAM = ('r') + ('C' << 8) + ('A' << 16) + ('M' << 24);
        const uint NOTE = ('N') + ('O' << 8) + ('T' << 16) + ('E' << 24);
        const uint IMAP = ('I') + ('M' << 8) + ('A' << 16) + ('P' << 24);

        bool Read(BinaryReader reader)
        {
            var magic = reader.ReadUInt32();
            if (magic != VOX_) {
                return false;
            }

            Version = reader.ReadInt32();

            var voxelData = null as VoxelData;

            while (reader.PeekChar() != -1) {
                var chunkId = reader.ReadUInt32();
                var chunkSize = reader.ReadInt32();
                var childChunksSize = reader.ReadInt32();

                var chunkName = System.Text.Encoding.ASCII.GetString(BitConverter.GetBytes(chunkId));

                switch (chunkId) {
                case MAIN: {
                        Debug.Assert(chunkSize == 0);
                    }
                    break;

                case PACK: {
                        var numModels = reader.ReadInt32();
                    }
                    break;

                case SIZE:
                    var sx = reader.ReadInt32();
                    var sy = reader.ReadInt32();
                    var sz = reader.ReadInt32();
                    Debug.Assert(chunkSize == sizeof(int) * 3);
                    voxelData = new VoxelData(new XYZ(sx, sy, sz));
                    Models.Add(voxelData);
                    break;

                case XYZI:
                    var n = reader.ReadInt32();
                    for (var i = 0; i < n; ++i) {
                        var x = reader.ReadByte();
                        var y = reader.ReadByte();
                        var z = reader.ReadByte();
                        var c = reader.ReadByte();
                        voxelData[new XYZ(x, y, z)] = new Voxel() { Index = c };
                    }
                    break;

                case RGBA:
                    // last color is not used, so we only need to read 255 colors
                    for (var i = 1; i < 256; ++i) {
                        byte r = reader.ReadByte();
                        byte g = reader.ReadByte();
                        byte b = reader.ReadByte();
                        byte a = reader.ReadByte();
                        Palette[i] = new Color(r,g,b,a);
                    }
                    // NOTICE : skip the last reserved color
                    reader.ReadUInt32();
                    break;

                case nTRN: {
                        var node = new TransformNode();
                        node.id = reader.ReadInt32();
                        node.attributes = ReadDICT(reader);
                        node.hidden = node.attributes.TryGetValue("_hidden", out var hidden) && hidden == "1";
                        node.attributes.TryGetValue("_name", out node.name);
                        Nodes.Add(node);

                        node.childNodeId = reader.ReadInt32();
                        var reservedId = reader.ReadInt32(); Debug.Assert(reservedId == -1);
                        node.layerId = reader.ReadInt32();

                        var numFrames = reader.ReadInt32(); Debug.Assert(numFrames > 0);
                        for (int i = 0; i < numFrames; i++) {
                            node.Frames.Add(TransformFrame.Read(reader));
                        }
                    }
                    break;

                case nGRP: {
                        var node = new GroupNode();
                        node.id = reader.ReadInt32();
                        node.attributes = ReadDICT(reader);
                        Nodes.Add(node);

                        var numChildNodes = reader.ReadInt32();
                        for (int i = 0; i < numChildNodes; i++) {
                            var childNodeId = reader.ReadInt32();
                            node.ChildNodeIds.Add(childNodeId);
                        }
                    }
                    break;

                case nSHP: {
                        var node = new ShapeNode();
                        node.id = reader.ReadInt32();
                        node.attributes = ReadDICT(reader);
                        Nodes.Add(node);

                        var numModels = reader.ReadInt32(); Debug.Assert(numModels > 0);
                        for (int i = 0; i < numModels; i++) {
                            node.Models.Add(ShapeModel.Read(reader));
                        }
                    }
                    break;

                case LAYR: {
                        var layer = Layer.Read(reader);
                        Layers[layer.layerId] = layer;
                    }
                    break;

                case MATL: {
                        var materialId = reader.ReadInt32();
                        var materialAttributes = ReadDICT(reader);

                        // TODO: Process materials
                    }
                    break;

                case rOBJ: {
                        var renderingAttributes = ReadDICT(reader);

                        // TODO: Process rendering
                    }
                    break;

                case rCAM: {
                        var cameraId = reader.ReadInt32();
                        var cameraAttributes = ReadDICT(reader);

                        // TODO: Process cameras
                    }
                    break;

                case NOTE: {
                        var numColorNames = reader.ReadInt32();

                        var colorNames = new List<string>();
                        for (int i = 0; i < numColorNames; i++) {
                            colorNames.Add(ReadSTRING(reader));
                        }
                    }
                    break;

                case IMAP: {
                        var paletteIndices = new List<byte>();
                        for (int i = 0; i < 256; i++) {
                            // NOTE: The online docs say it's an array of int32 but in fact it's an array of int8 (bytes).
                            // https://github.com/ephtracy/voxel-model/blob/master/MagicaVoxel-file-format-vox-extension.txt
                            // https://github.com/ephtracy/voxel-model/issues/19#issuecomment-739324018
                            paletteIndices.Add(reader.ReadByte());  
                        }
                    }
                    break;

                default:
                    Console.WriteLine($"Skipping unknown chunk: '{chunkName}'");
                    reader.ReadBytes(chunkSize);
                    break;
                }
            }

            // When no nodes exist just add the palette to the first  
            if (Nodes.Count == 0) {
                Models[0].Colors = Palette;
            }
 
            return true;
        }

        static DICT ReadDICT(BinaryReader reader) {
            var n = reader.ReadInt32();
            var dict = new DICT();

            for (var i=0; i < n; i++) {
                dict.Add(ReadSTRING(reader), ReadSTRING(reader)); 
            }

            return dict;
        }

        static string ReadSTRING(BinaryReader reader) {
            var bufferSize = reader.ReadInt32();
            var buffer = reader.ReadBytes(bufferSize);
            return System.Text.Encoding.ASCII.GetString(buffer);
        }

        void Write(BinaryWriter writer) {
            var packSize = 4 * 4;
            var sizeSize = 6 * 4 * Models.Count;
            var xyziSize = 4 * 4 + Models.Select(voxelData => voxelData.Count * 4).Sum();
            var rgbaSize = 3 * 4 + (256 * 4);
            var mainSize = packSize+(sizeSize+xyziSize)*1+rgbaSize;

            writer.Write(VOX_); // Magic
            writer.Write(Version); // Version

            writer.Write(MAIN); // chunkId
            writer.Write(0); // chunkSize
            writer.Write(mainSize); // childChunksSize

            writer.Write(PACK); // chunkId
            writer.Write(4); // chunkSize
            writer.Write(0); // childChunksSize
            writer.Write(Models.Count); // num child models

            for (var i=0; i < Models.Count; ++i) {
                var voxelData = Models[i];

                writer.Write(SIZE); // chunkId
                writer.Write(3*4); // chunkSize
                writer.Write(0); // childChunksSize
                writer.Write(voxelData.Size.X);
                writer.Write(voxelData.Size.Y); 
                writer.Write(voxelData.Size.Z);

                writer.Write(XYZI); // chunkId
                writer.Write((voxelData.Count+1)*4); // chunkSize
                writer.Write(0); // childChunksSize
                writer.Write(voxelData.Count); // Count of Voxels where IsVisible is true
                foreach (var p in voxelData) {
                    var v = voxelData[p];
                    if (v.IsVisible) {
                        writer.Write((byte)p.X);
                        writer.Write((byte)p.Y);
                        writer.Write((byte)p.Z);
                        writer.Write((byte)v.Index);
                    }
                }
            }

            if (Palette != null) {
                writer.Write(RGBA); // chunkId
                writer.Write(256 * 4); // chunkSize
                writer.Write(0); // childChunksSize
                foreach (var c in Palette.Skip(1)) {
                    writer.Write((byte)c.R);
                    writer.Write((byte)c.G);
                    writer.Write((byte)c.B);
                    writer.Write((byte)c.A);
                }
                writer.Write(0); // Empty voxel color
            }
        }

        public bool Read(Stream stream) {
            return Read(new BinaryReader(stream));
        }
        public void Write(Stream stream) {
            Write(new BinaryWriter(stream));
        }

        bool IsVisible(TransformNode transform) {
            if (transform.hidden) {
                return false;
            }
            if (Layers.TryGetValue(transform.layerId, out var layer) && layer.hidden) {
                return false;
            }
            return true;
        }

        public BoundsXYZ GetWorldAABB(int startFrame, int endFrame) {
            if (Nodes.Count == 0) {
                return Models[0].Bounds;
            }
            var worldBounds = BoundsXYZ.CreateEmpty();
            for (int frame = startFrame; frame <= endFrame; frame++) {
                GetWorldAABB(frame, Nodes[0], Matrix4x4.Identity, worldBounds);
            }
            return worldBounds;
        }

        // Render the tree of nodes to a single set of VoxelData
        public VoxelData Flatten(BoundsXYZ worldBounds, int frame = 0) {
            if (Nodes.Count > 0) {
                var voxelData = new VoxelData(worldBounds.Size, Palette);
                var origin = (worldBounds.Size - XYZ.One) / 2;
                var matrix = Matrix4x4.CreateTranslation(-worldBounds.Min.ToVector3());
                CollateVoxelData(frame, Nodes[0], matrix, voxelData);
                return voxelData;
            }
            else {
                return Models[0];
            }
        }

        // Render the tree of nodes to a single set of VoxelData
        public VoxelData Flatten(int frame = 0) {
            if (Nodes.Count > 0) {
                var worldBounds = GetWorldAABB(frame, frame);

                var voxelData = new VoxelData(worldBounds.Size, Palette);
                var matrix = Matrix4x4.CreateTranslation(-worldBounds.Min.ToVector3());
                CollateVoxelData(frame, Nodes[0], matrix, voxelData);
                return voxelData;
            }
            else {
                return Models[0];
            }
        }


        void GetWorldAABB(int frameIndex, Node node, Matrix4x4 parentMatrix, BoundsXYZ worldBounds) {
            if (node is TransformNode transform && IsVisible(transform)) {
                var newMatrix = transform.GetFrameMatrix(frameIndex) * parentMatrix;
                if (transform.childNodeId >= 0) {
                    var childNode = Nodes[transform.childNodeId];
                    GetWorldAABB(frameIndex, childNode, newMatrix, worldBounds);
                }
            }

            if (node is GroupNode group) {
                foreach (var childNodeId in group.ChildNodeIds) {
                    var childNode = Nodes[childNodeId];
                    GetWorldAABB(frameIndex, childNode, parentMatrix, worldBounds);
                }
            }

            if (node is ShapeNode shape) {
                var shapeModel = shape.GetModel(frameIndex);

                var model = Models[shapeModel.modelId];
                var bounds = new BoundsXYZ(model.Size);
                bounds = bounds.Transform(parentMatrix);
                worldBounds.Add(bounds);
            }
        }

        void CollateVoxelData(int frameIndex, Node node, Matrix4x4 parentMatrix, VoxelData voxelData) {
            if (node is TransformNode transform && IsVisible(transform)) {
                var newMatrix = transform.GetFrameMatrix(frameIndex) * parentMatrix;
                if (transform.childNodeId >= 0) {
                    var childNode = Nodes[transform.childNodeId];
                    CollateVoxelData(frameIndex, childNode, newMatrix, voxelData);
                }
            }

            if (node is GroupNode group) {
                foreach (var childNodeId in group.ChildNodeIds) {
                    var childNode = Nodes[childNodeId];
                    CollateVoxelData(frameIndex, childNode, parentMatrix, voxelData);
                }
            }

            if (node is ShapeNode shape) {
                var shapeModel = shape.GetModel(frameIndex);

                var model = Models[shapeModel.modelId];
                var origin = new BoundsXYZ(model.Size).Min;

                foreach (var p in model) {
                    var v = model[p];
                    if (v.IsVisible) {
                        // Transform local voxel position to node relative position (origin at 0,0,0)
                        var n = p + origin;
                        var q = XYZ.FromVector3(Vector3.Transform(n.ToVector3(), parentMatrix));
                        //if (voxelData.IsValid(q)) {
                            voxelData[q] = v;
                        //}
                        //else {
                            // Off by one error here. Not sure from where...
                        //}
                    }
                }
            }
        }
    }
}
