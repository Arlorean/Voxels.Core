using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using static Voxels.MagicaVoxel;

namespace Voxels {
    /// <summary>
    /// Support for reading .QB files generated by Minidesk's Qubicle Tool.
    /// http://minddesk.com/learn/article.php?id=22
    /// </summary>
    public class QbFile {
        public uint Version { get; private set; } = 200;

        VoxelDataColors voxelData;

        const uint CODEFLAG = 2;
        const uint NEXTSLICEFLAG = 6;

        public QbFile() { }

        public VoxelData Flatten() { return voxelData; }

        bool Read(BinaryReader reader) {
            // Version bytes are major, minor, release, build
            Version = reader.ReadUInt32();

            var colorFormat = reader.ReadInt32(); // 0=RGBA, 1=BGRA
            var zAxisOrientation = reader.ReadInt32(); // 0=LeftHanded, 1=RightHanded
            var compression = reader.ReadInt32(); // 1=compressed, 0=uncompressed
            var visibilityMaskEncoded = reader.ReadInt32(); // 0=A->0(invisible),255(visible), 1=A->side visibility
            var matrixCount = reader.ReadInt32();

            var matrices = new List<VoxelData>();
            var positions = new List<XYZ>();
            for (var i = 0; i < matrixCount; ++i) {
                var nameLength = reader.ReadByte();
                var name = Encoding.UTF8.GetString(reader.ReadBytes(nameLength));
                var sizeX = reader.ReadInt32();
                var sizeY = reader.ReadInt32();
                var sizeZ = reader.ReadInt32();
                var posX = reader.ReadInt32();
                var posY = reader.ReadInt32();
                var posZ = reader.ReadInt32();

                Func<uint, Voxel> colorFn = (v) => {
                    var c = colorFormat == 0 ? Color.FromRGBA(v) : Color.FromBGRA(v);
                    return new Voxel(new Color(c, c.A == 0 ? byte.MinValue : byte.MaxValue));
                };
                positions.Add(new XYZ(posX, posY, posZ));

                var matrix = new VoxelDataColors(new XYZ(sizeX, sizeY, sizeZ));
                if (compression == 0) {
                    for (var z = 0; z < sizeZ; z++) {
                        for (var y = 0; y < sizeY; y++) {
                            for (var x = 0; x < sizeX; x++) {
                                matrix[new XYZ(x, y, z)] = colorFn(reader.ReadUInt32());
                            }
                        }
                    }
                }
                else {
                    var z = 0;

                    while (z < sizeZ) {
                        var index = 0;

                        while (true) {
                            var data = reader.ReadUInt32();

                            if (data == NEXTSLICEFLAG) {
                                break;
                            }
                            if (data == CODEFLAG) {
                                var count = reader.ReadUInt32();
                                data = reader.ReadUInt32();

                                for (var j = 0; j < count; j++) {
                                    var x = index % sizeX; // mod = modulo e.g. 12 mod 8 = 4
                                    var y = index / sizeX; // div = integer division e.g. 12 div 8 = 1
                                    index++;
                                    matrix[new XYZ(x,y,z)] = colorFn(data);
                                }
                            }
                            else {
                                var x = index % sizeX;
                                var y = index / sizeX;
                                index++;
                                matrix[new XYZ(x,y,z)] = colorFn(data);
                            }
                        }

                        z++;
                    }
                }

                matrices.Add(matrix);
            }

            // Combine matrices into overall matrix
            var minExtents = Enumerable.Range(0, matrixCount)
                .Aggregate(XYZ.Max, (a, i) => {
                    var v = positions[i];
                    return new XYZ(Math.Min(a.X, v.X), Math.Min(a.Y, v.Y), Math.Min(a.Z, v.Z));
                });
            var maxExtents = Enumerable.Range(0, matrixCount)
                .Aggregate(XYZ.Min, (a, i) => {
                    var v = positions[i] + matrices[i].Size;
                    return new XYZ(Math.Max(a.X, v.X), Math.Max(a.Y, v.Y), Math.Max(a.Z, v.Z));
                });
            var extents = maxExtents - minExtents;
            var voxelData = new VoxelDataColors(extents);

            for (var i = 0; i < matrixCount; ++i) {
                var matrix = matrices[i];
                var offset = positions[i] - minExtents; // Start at 0,0,0

                for (var x = 0; x < matrix.Size.X; ++x) {
                    for (var y = 0; y < matrix.Size.Y; ++y) {
                        for (var z = 0; z < matrix.Size.Z; ++z) {
                            var pos = new XYZ(x, y, z);
                            voxelData[pos+offset] = matrix[pos];
                        }
                    }
                }
            }

            // Orient .qb so thumbnail matches Qubicle default view
            var s = voxelData.Size;
            var d = new VoxelDataColors(new XYZ(s.X, s.Z, s.Y));
            foreach (var i in voxelData) {
                if (zAxisOrientation == 0) { // LEFT
                    d[new XYZ(i.X, s.Z - 1 - i.Z, i.Y)] = voxelData[i];
                }
                else { // RIGHT
                    d[new XYZ(i.X, i.Z, i.Y)] = voxelData[i];
                }
            }

            this.voxelData = d;
            return true;
        }

        public bool Read(Stream stream) {
            return Read(new BinaryReader(stream));
        }

        public static VoxelData ReadAndFlatten(Stream stream) {
            var quibicle = new QbFile();
            quibicle.Read(stream);
            return quibicle.Flatten();
        }
    }
}
